[toc]



#  面试问题整理 

## 计算机基础

1. 简述OSI七层网络模型，TCP/IP四层网络模型

   OSI七层网络模型，网络的七层加工从下到上主要包括物理层，数据链路层，网络层，传输层，会话层，表示层，应用层

   这个是OSI七层网络模型：

   ![微信图片_20201222143923](https://homan-blog.oss-cn-beijing.aliyuncs.com/interview/img_20201222143923.png)

2. 简述TCP三次握手以及四次挥手

   TCP三次握手的过程如下：
    （1）客户端发送SYN(seq=x)报文给服务器端，进入SYN_SEND状态。
    （2）服务器端收到SYN报文，回应一个SYN(seq=y)和ACK(ack = x+1)报文，进入SYN_RECV状态。
    （3）客户端收到服务器端的SYN报文，回应一个ACK(ack=y+1)报文，进入Established状态。
     TCP三次握手的过程图

   ![微信图片_20201222144105](https://homan-blog.oss-cn-beijing.aliyuncs.com/interview/img_20201222144105.png)

   TCP四次挥手的过程如下

   ![微信图片_20201222144148](https://homan-blog.oss-cn-beijing.aliyuncs.com/interview/img_20201222144148.png)

3. 

## Java 基础

1. hashcode和equals, 什么时候用到hashcode, 重写hashcode会出现什么现象？
2. 1.8的新特性了解的说一下
3. 泛型是干什么的, 讲一下

## 集合

1.  HashMap源码, ConConcurrentHashMap源码

   有什么异同, 

   后者怎么保证线程安全的,

    1.8与之前有什么区别,

    hashmap什么时候变成红黑树, 

   什么时候退化成链表, 

   怎么解决hash冲突, 

   为什么要用红黑树

   红黑树有什么特点

   红黑树插入和查找的时间复杂度

2. 简述HashMap的底层原理
   - hash算法：为什么要高位和低位做异或运算？答：让高位也参与hash寻址运算，降低hash冲突
   - hash寻址：为什么是hash值和数组.length - 1进行与运算？答：因为取余算法效率很低，按位与运算效率高
   - hash冲突的机制：链表，超过8个以后，红黑树（数组的容量大于等于64）
   - 扩容机制：数组2倍扩容，重新寻址（rehash），hash & n - 1，判断二进制结果中是否多出一个bit的1，如果没多，那么就是原来的index，如果多了出来，那么就是index + oldCap，通过这个方式。就避免了rehash的时候，用每个hash对新数组.length取模，取模性能不高，位运算的性能比较高
     JDK 1.8以后，优化了一下，如果一个链表的长度超过了8，就会自动将链表转换为红黑树，查找的性能，是O(logn)，这个性能是比O(n)要高的
   - 红黑树是二叉查找树，左小右大，根据这个规则可以快速查找某个值
   - 但是普通的二叉查找树，是有可能出现瘸子的情况，只有一条腿，不平衡了，导致查询性能变成O(n)，线性查询了
   - 红黑树，红色和黑色两种节点，有一大堆的条件限制，尽可能保证树是平衡的，不会出现瘸腿的情况
   - 如果插入节点的时候破坏了红黑树的规则和平衡，会自动重新平衡，变色（红 <-> 黑），旋转，左旋转，右旋转

3. hashset是什么数据结构?



4. 

## 并发编程

1. 线程有几种状态，状态之间的变化是怎样的？

   Java线程在运行的声明周期中可能处于6种不同的状态，在给定的一个时刻，线程只能处于其中的一个状态

   这里我弄了几张图：

   线程有几种状态，状态之间的变化是怎样的？

   ![微信图片_20201222143640](https://homan-blog.oss-cn-beijing.aliyuncs.com/interview/img_20201222143640.png)

   java线程状态变迁

   ![微信图片_20201222143706](https://homan-blog.oss-cn-beijing.aliyuncs.com/interview/img_20201222143706.png)

2. Threadlocal解释一下

   会出现什么问题

   异步情况怎么解决

3. synchronize和retreentlock解释一下

   原理, 作用, 异同

   并发量大用什么, 小用什么

   sync做了哪些优化

   锁升级

   锁粗化

   锁消除

4. AQS, CAS, 解释一下

   AQS有哪些应用, 或者衍生物有哪些

   CAS解释一下, CPU指令?

5. authomic类了解吗, 解释一下

6. 原子性, 可见性, 有序性怎么保证的

7. 介绍一下volitile

   - 硬件级别原理图

     ![微信图片_20201222142022](https://homan-blog.oss-cn-beijing.aliyuncs.com/interview/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20201222142022.png)

   - java内存模型图

     ![img_20201222142438](https://homan-blog.oss-cn-beijing.aliyuncs.com/interview/img_20201222142438.png)

   - 可见性：一个线程修改了变量，其他线程能马上读取到该变量的最新值。  read（从主存读取），load（将主存读取到的值写入工作内存），use（从工作内存读取数据来计算），assign（将计算好的值重新赋值到工作内存中），store（将工作内存数据写入主存），write（将store过去的变量值赋值给主存中的变量）

     ![微信图片_20201222142608](https://homan-blog.oss-cn-beijing.aliyuncs.com/interview/img_20201222142608.png)

   - volatile读的内存语义如下：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。
         这个是流程图：

     ![微信图片_20201222142940](https://homan-blog.oss-cn-beijing.aliyuncs.com/interview/img_20201222142940.png)

     - 当读flag变量后，本地内存B包含的值已经被置为无效。此时，线程B必须从主内存中读取共享变量，线程B的读取操作将导致本地内存B与主内存
        中的共享变量的值变成一致。
     - volatile写和volatile读的内存语义总结：
        线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了（其对共享变量所做修改的）消息。
        线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息。
        线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。

   - 锁的释放和获取的内存语义：当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。
       当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取变量。

   - 有序性：基于happens-before原则来看volatile关键字如何保证有序性 
        这个是流程图：

     ![微信图片_20201222143043](https://homan-blog.oss-cn-beijing.aliyuncs.com/interview/img_20201222143043.png)

     happens-before规则
      （6-1）程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
      （6-2）监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
      （6-3）volatile变量规则：对一个volatile变量域的写，happens-before于任意后续对这个volatile域的读
      （6-4）传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
      （6-5）start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
      （6-6）join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before与线程A从ThreadB.join()操作成功返回。

   - 原子性：volatile关键字不能保证原子性，唯一的场景就是在32位虚拟机，对long/double变量的赋值写是原子的，volatile关键字底层原理，lock指令以及内存屏，
     （8）lock指令：volatile实现的两条原则
      （8-1）Lock前缀指令会引起处理器缓存回写到内存。
      （8-2）一个处理器的缓存回写到内存会导致其他处理器的缓存失效。
      （8-3）缓存一致性协议：

     ​	![微信图片_20201222143145](https://homan-blog.oss-cn-beijing.aliyuncs.com/interview/img_20201222143145.png)

8. 

## JVM

1. 介绍一下jmm

1. mesi协议解释一下, 在没有该协议的时候是怎么做的

1. 内存屏障了解吗, 讲一下

1. 类加载器讲一下

1. 双亲委派机制讲一下, 从源码讲一下, 怎么先上寻找再向下寻找的

1. 类加载机制说一下, 说一下每一步的作用 加载-验证--======

1. JVM内存模型, 每个区域都存放着什么?

1. 垃圾回收器 垃圾回收算法

1. cms回收流程描述一下, G1呢?

1. 针对于CMS, 有哪些独有的参数呢?

1. oom会发生在哪里? 各自怎么处理

1. 线上oom了, 怎么处理, 处理过程, 用哪些命令

1. 我想看一下我的java的进程所占用的硬件指标怎么看, 用什么? 比如想看一下cpu, memory等

1. 我想看一下我的jvm占用的硬件指标怎么看?

1. jvm参数你们是怎么设置的, 大致都有哪些参数, 聊一聊

1. zgc

1. CMS垃圾回收的过程

   这个是JVM内存划分的图：

   ![微信图片_20201222144247](https://homan-blog.oss-cn-beijing.aliyuncs.com/interview/img_20201222144247.png)

   这里援引下儒猿群群友根据《从 0 开始带你成为JVM实战高手》专栏 总结出来的图，分享给大家，https://www.processon.com/view/link/5e69db12e4b055496ae4a673

   CMS的工作机制相对复杂，垃圾回收过程包含如下4个步骤
   （1）初始标记：只标记和GC Roots直接关联的对象，速度很快，需要暂停所有工作线程。
   （2）并发标记：和用户线程一起工作，执行GC Roots跟踪标记过程，不需要暂停工作线程。
   （3）重新标记：在并发标记过程中用户线程继续运行，导致在垃圾回收过程中部分对象的状态发生变化，为了确保这部分对象的状态正确性，需要对其重新标记并暂停工作线程。
   （4）并发清除：和用户线程一起工作，执行清除GC Roots不可达对象的任务，不需要暂停工作线程。

1. G1与CMS的区别，你们公司使用的是哪个，为什么？（这个需要结合自己的业务场景回答）
   相对于CMS垃圾收集器，G1垃圾收集器两个突出的改进。
   （1）基于标记整理算法，不产生内存碎片。
   （2）可以精确地控制停顿时间，在不牺牲吞吐量的前提下实现短停顿垃圾回收。

1. 问题：JVM参数举例，讲讲为什么这么设置，为了避免fullGC的停顿对系统的影响，有哪些解决方案？
   由于文本不方便贴代码，贴在在了有道云笔记里面：http://note.youdao.com/s/X4Qmucr0
   为解决应用在午高峰发生 full gc 而影响系统响应时间问题, 考虑低峰期主动进行 full gc 对 old 区进行释放.
   确保启动参数中 -XX:+DisableExplicitGC 项被删除, 该参数作用是禁止 System.gc() 调用. (启动参数一般配在 start 脚本中)
   在启动参数中加入 -XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses, 该参数的作用是主动 System.gc() 时调用 CMS 算法进行 gc 操作.

1. 问题：内存模型以及分区，需要详细到每个区放什么
   JVM 分为堆区和栈区，还有方法区，初始化的对象放在堆里面，引用放在栈里面， class 类信息常量池(static 常量和 static 变量)等放在方法区
    （1） 方法区:主要是存储类信息，常量池(static 常量和 static 变量)，编译后的代码(字 节码)等数据
    （2） 堆:初始化的对象，成员变量 (那种非 static 的变量)，所有的对象实例和数组都要 在堆上分配

   （3） 栈:栈的结构是栈帧组成的，调用一个方法就压入一帧，帧上面存储局部变量表，操 作数栈，方法出口等信息，局部变量表存放的是 8 大基础类型加上一个应用类型，所 以还是一个指向地址的指针
    （4） 本地方法栈:主要为 Native 方法服务
    （5） 程序计数器:记录当前线程执行的行号

1. 问题：JVM内存分那几个区，每个区的作用是什么？
    java 虚拟机主要分为以下一个区:
    方法区:

    1. 有时候也成为永久代，在该区内很少发生垃圾回收，但是并不代表不发生 GC，在这里 进行的 GC 主要是对方法区里的常量池和对类型的卸载

   2. 方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后 的代码等数据。
    3. 该区域是被线程共享的。
    4. 方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池 具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量 池中。

 1. 虚拟机栈:
    1. 虚拟机栈也就是我们平常所称的栈内存,它为 java 方法服务，每个方法在执行的时候都
     会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。
    2. 虚拟机栈是线程私有的，它的生命周期与线程相同。
    3. 局部变量表里存储的是基本数据类型、returnAddress 类型(指向一条字节码指令的地 址)和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表 对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定

    4.操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索 引来访问，而是压栈和出栈的方式 5.每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了 支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接 引用。

    本地方法栈和虚拟机栈类似，只不过本地方法栈为 Native 方法服务。
    堆：
    java 堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这 里创建，因此该区域经常发生垃圾回收操作。
    程序计数器 内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码 指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内 存区域是唯一一个 java 虚拟机规范没有规定任何 OOM 情况的区域。

1. 问题：堆里面的分区：Eden，survival (from+ to)，老年代，各自的特点。
   堆里面分为新生代和老生代(java8 取消了永久代，采用了 Metaspace)，新生代包 含 Eden+Survivor 区，
   survivor 区里面分为 from 和 to 区，内存回收时，如果用的是复 制算法，
   从 from 复制到 to，当经过一次或者多次 GC 之后，存活下来的对象会被移动 到老年区，当 JVM 内存不够用的时候，
   会触发 Full GC，清理 JVM 老年区 当新生区满了之后会触发 YGC,先把存活的对象放到其中一个 Survice 区，然后进行垃圾清理。
   因为如果仅仅清理需要删除的对象，这样会导致内存碎 片，因此一般会把 Eden 进行完全的清理，然后整理内存。那么下次 GC 的时候， 
   就会使用下一个 Survive，这样循环使用。如果有特别大的对象，新生代放不下， 就会使用老年代的担保，直接放到老年代里面。因为 JVM 认为，一般大对象的存 活时间一般比较久远

1. 问题：如何判断一个对象是否存活？（或者GC对象的判定方法）
   判断一个对象是否存活有两种方法:
   1. 引用计数法 所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象 时，
   就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说 明此对象没有被引用，
   也就是“死对象”,将会被垃圾回收. 引用计数法有一个缺陷就是无法解决循环引用问题，
   也就是说当对象 A 引用对象 B，对象 B 又引用者对象 A，那么此时 A,B 
   对象的引用计数器都不为零，也就造成无法完成垃圾回 收，所以主流的虚拟机都没有采用这种算法。
   2. 可达性算法(引用链法)
     该算法的思想是:从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。
     在 java 中可以作为 GC Roots 的对象有以下几种: • 虚拟机栈中引用的对象
     方法区类静态属性引用的对象 • 方法区常量池引用的对象
   3. 本地方法栈 JNI 引用的对象 虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比不一 定会被回收。当一个对象不可达 GC Root 时，这个对象并 不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记 如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行 一次筛选，筛选的条件是是否有必要执行 finalize()方法。当对象没有覆盖 finalize()方法
     或者已被虚拟机调用过，那么就认为是没必要的。
   4. 如果该对象有必要执行 finalize()方法，那么这个对象将会放在一个称为 F-Queue 的对队 列中，虚拟机会触发一个 Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承 诺一直等待它运行完，这是因为如果 finalize()执行缓慢或者发生了死锁，那么就会造成 F- Queue 队列一直等待，造成了内存回收系统的崩溃。GC 对处于 F-Queue 中的对象进行 第二次被标记，这时，该对象将被移除”即将回收”集合，等待回收。

1. 问题：服务类加载过多引发的OOM问题如何排查
   如果服务出现无法调用接口假死的情况，首先要考虑的是两种问题
   （1）第一种问题，这个服务可能使用了大量的内存，内存始终无法释放，因此导致了频繁GC问题。
   也许每秒都执行一次Full GC，结果每次都回收不了多少，最终导致系统因为频繁GC，频繁Stop the World，接口调用出现频繁假死的问题
   （2）第二种问题，可能是这台机器的CPU负载太高了，也许是某个进程耗尽了CPU资源，导致你这个服务的线程始终无法得到CPU资源去执行，
   也就无法响应接口调用的请求。这也是一种情况。

1. 在内存使用这么高的情况下会发生什么？
   第一种，是内存使用率居高不下，导致频繁的进行Full GC，gc带来的stop the world问题影响了服务。
   第二种，是内存使用率过多，导致JVM自己发生OOM。
   第三种，是内存使用率过高，也许有的时候会导致这个进程因为申请内存不足，直接被操作系统把这个进程给杀掉了

1. 问题：如何在JVM内存溢出的时候自动dump内存快照？
   -XX:+HeapDumpOnOutOfMemoryError
   -XX:HeapDumpPath=/usr/local/app/oom
   第一个参数意思是在OOM的时候，自动dump内存快照出来，第二个参数是说把内存快照放到哪去
   自己阅读的书籍举例：《实战Java虚拟机：JVM故障诊断与性能优化（第2版）》

1. 



## Netty

1. BIO NIO了解嘛， 说一下

2. epoll， poll， select说一下

3. Netty知识点对应的老师的课程：《Netty核心功能精讲以及核心源码剖析》
   问题：NIO开发的话为什么选择netty
   不选择Java原生NIO编程的原因
   （1）NIO的类库和API的繁杂，使用麻烦，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。
   （2）需要具备其他的额外技能做铺垫，例如熟悉Java多线程编程。这是因为NIO编程涉及到Reactor模式，你必须对多线程和网络编程非常熟悉，才能写出高质量的NIO程序。

   （3）可靠性能力补齐，工作量和难度都非常大。例如客户端面临重连、网络闪断、半包读写、失败缓存、网络拥塞和异常码流的处理的问题，NIO编程的特点就是功能开发相对
   容易，但是可靠性能力补齐工作量和难度都非常大
   （4）JDK NIO的BUG，例如臭名昭著的epoll bug，它会导致Selector空轮询，最终导致CPU 100%
   为什么选择Netty
   （1）API使用简单，开发门槛低；
   （2）功能强大，预置了多种编解码弄能，支持多种主流协议；
   （3）定制能力强，可以通过ChannelHandler对通信框架进行灵活地扩展；

   （4）性能高，通过与其他业界主流的NIO框架对比，Netty的综合性能最优；
   （5）成熟、稳定，Netty修复了已经发现的所有JDK NIO BUG，业务开发人员不需要再为NIO的BUG而烦恼；
   （6）社区活跃，版本迭代周期短，发现的BUG可以被及时修复，同时，更多的新功能会加入；
   （7）经历了大规模的商业应用考验，质量得到验证。

4. 问题：简述TCP粘包拆包以及解决方案
    开局一个图：![微信图片_20201222144859](https://homan-blog.oss-cn-beijing.aliyuncs.com/interview/img_20201222144859.png)
   假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下4种情况

   （1）服务端分两次读取到了两个独立的数据包，分别是D1和D2，没有粘包和拆包；
   （2）服务端一次接收到了两个数据包，D1和D2粘合在一起，被称为TCP粘包；
   （3）服务端分两次读取到了两个数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这被称为TCP拆包；
   （4）服务端分两次读取到了两个数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余内容D1_2和D2包的整包。
   TCP粘包/拆包发生的原因
   （1）应用程序write写入的字节大小大于套接口发送缓冲区大小；
   （2）进行MSS（Maxitum Segment Size 最大分段大小）大小的TCP分段；
   （3）以太网帧的payload大于MTU（Maxitum Transmission Unit 最大传输单元）进行IP分片。

   粘包问题的解决策略
   （1）消息定长，例如每个报文的大小为固定长度200字节，如果不够，空位补空格；
   （2）在包尾增加回车换换符进行分割，例如FTP协议；
   （3）将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思想为消息头的一个字段使用int32来表示消息的总长度；
   （4）更复杂的应用层协议。

5. 问题：简述netty服务端和客户端创建的流程
    看下这个图：,在面试的时候回答这个图里面的流程

   ![微信图片_20201222145213](https://homan-blog.oss-cn-beijing.aliyuncs.com/interview/img_20201222145213.png)

6. 问题：简述Netty的线程模型（这个最好画图，显示出自己思路清新） 
    现场画图：

   ![微信图片_20201222145238](https://homan-blog.oss-cn-beijing.aliyuncs.com/interview/img_20201222145238.png)

7. 问题：Netty解决了java原生NIO哪些问题（空轮询的bug，这个一定要说出来） 
    大家看下这个博客写的挺好的：https://blog.csdn.net/baiye_xing/article/details/73351330

## Spring

1. IOC说一下, 怎么解决循环依赖的, 三级缓存,第三级可以不用吗
2. AOP说一下, AOP用来干什么, 能干什么, 有哪些注解或者功能,  filter, intercept有啥区别
3. jdk代理,cglib代理说一下
4. bean的声明周期说一下
5. spring mvc知道嘛?说一下原理

## Spring Boot

## MQ

1. 说一下你了解的mq的原理吧
2. 怎么保证消息一定不丢呢?
3. 怎么保证消息是顺序的呢?
4. 怎么做幂等的呢?
5. Kafka、RabbitMQ他们有类似的数据分片机制吗？他们是如何把一个逻辑上的数据集合概念（比如一个Topic）给在物理上拆分为多个数据分片的？然后拆分后的多个数据分片又是如何在物理的多台机器上分布式存储的？
6. 为什么一定要让MQ实现数据分片的机制？如果不实现数据分片机制，让你来设计MQ中一个数据集合的分布式 存储，你觉得好设计吗？
7. 同步刷盘和异步刷盘两种策略，分别适用于什么不同的场景呢？
8. 异步刷盘可以提供超高的写入吞吐量，但是有丢失数据的风险，这个适用于什么业务场景？在你所知道的业务场景，或者工作接触过的业务场景中，有哪些场景需要超高的写入吞吐量，但是可以适度接受数据丢失？
9. 同步刷盘会大幅度降低写入吞吐量，但是可以让你的数据不丢失，你接触哪些场景，是严格要求数据务必不能丢失任何一条，但是吞吐量并没有那么高的呢？
10. Kafka、RabbitMQ他们的broker收到消息之后是如何写入磁盘的？采用的是同步刷盘还是异步刷盘的策略？为什么？
11. 每次写入都必须有超过半数的Follower Broker都写入消息才可以算做一次写入成功，那么大家思考一个问题，这样做是不是会对Leader Broker的写入性能产生影响？是不是会降低TPS？是不是必须要在所有的场景都这么做？为什么呢？
12. 一般我们获取到一批消息之后，什么时候才可以认为是处理完这批消息了？是刚拿到这批消息就算处理完吗？还是说要对这批消息执行完一大堆的数据库之类的操作，才算是处理完了？
13. 如果获取到了一批消息，还没处理完呢，结果机器就宕机了，此时会怎么样？这些消息会丢失，再也无法处理了吗？如果获取到了一批消息，已经处理完了，还买来得及提交消费进度，此时机器宕机了，会怎么样呢？
14. 消费者机器到底是跟少数几台Broker建立连接，还是跟所有Broker都建立连接？
15. RocketMQ是支持主从架构下的读写分离的，而且什么时候找Slave Broker读取大家也都了解的很清楚了，那么大家思考一下，Kafka、RabbitMQ他们支持主从架构下的读写分离吗？支持Slave Broker的读取吗？为什么呢？
16. 如果支持读写分离的话，有没有一种可能，就是出现主从数据不一致的问题？比如有的数据刚刚到Master Broker和部分Slave Broker，但是你刚好是从那个没有写入数据的Slave Broker去读取了？
17. 消费吞吐量似乎是跟你的处理速度有很大关系，如果你消费到一批数据，处理太慢了，会导致你严重跟不上数据写入的速度，这会导致你后续几乎每次拉取数据都会从磁盘上读取，而不是os cache里读取，所以你觉得你在拉取到一批消息处理的时候，应该有哪些要点需要注意的？

### Kafka

## MySQL

1. 讲一下隔离级别, 每种隔离级别会带来什么问题, 默认是哪个

2. 索引 聚簇索引, 非聚簇索引, 索引的结构, b树, b+树的区别,  哪些操作会用不到索引?

3. 联合索引的数据结构是什么样的? 举个例子收一下查找的过程

4. 一条sql提交之后mysql发生了什么, 执行流程说一下

5. redo log, undo log binlog说一下

6. buffer pool了解吗, 说一下, 怎么刷新到磁盘的, 挂了数据会丢失吗

7. RR, RC, RU, serializable都会产生什么问题?

8. innoDB的锁有哪些, 行锁, gap锁, Next-key锁, 都是干啥用的

9. 做过sql调优吗, 从哪些方面? 数据库本身, 业务, sql本身

10. 说一下explain的关键的几个参数, 怎么看

11. 怎么进行分库分表的, 按照什么维度, 出现夸库, 夸表的查询吗

12. 分布式id怎么弄得

13. 一条sql执行的很慢怎么弄?
    偶尔慢是什么原因?

    ​	db在刷新脏页

    ​		redo log写满了

    ​		内存不够用, 要从lru链表中淘汰

    ​		mysql自己认为系统空闲的时候

    ​		mysql关闭的时候
    ​	拿不到锁

    一直都这么慢是什么原因?
    	没有索引
    	有索引没用
    	索引加的不是最优的
    	mysql执行引擎用的不是最优的索引

14. 死锁知道吗, 我用sql怎么实现一个死锁?

15. mysql对死锁怎么优化的?

16. mysql怎么查看死锁

17. 原理图

    ![image-20201222141254709](https://homan-blog.oss-cn-beijing.aliyuncs.com/interview/image-20201222141254709.png)

18. 

## 分布式和微服务

1. 分布式事务知道吗, 怎么解决的, 说一下?
2. 分布式锁用过吗, 说一下, 除了redis, zk知道吗, 说一下
3. 链路追踪怎么做的?
4. rpc框架用的什么? http?为什么用http?   tcp 为什么用tcp
5. 网关是用来做什么的, 你们用什么实现的网关?
6. 如何设计一个扛得住亿级流量的网关?
7. 限流的算法有哪些?
8. 为什么要分布式id, 你知道有哪些
9. 如果你要设计rpc框架你怎么设计
10. 谈一谈你对微服务的理解
11. 如何保证缓存一致性的
12. 系统如何保护、限流、熔断、隔离、降级

## 网络

1. tcp三次握手, 四次挥手
2. 为什么三次, 两次四次行不行
3. 为什么2msl  msl是什么
4. 说一下一次http请求的流程?
5. osi七层模型知道吗? 每一层简单讲一下, 四层呢?
6. 什么叫做拆包, 黏包
7. 包的结构知道吗, 说一下
8. 怎么解决黏包
9. 你们目前公司网络拓扑可以简单说一下嘛

## 数据结构和算法

1. 链表

   两个链表相交, 查找第一个交点

   查找链表的倒数第k个元素

   两个有序链表合并

   合并k个有序链表

   链表反转

   一个有环的链表的环的入口

2. 数组

   给定一个目标值, 在该数组中有且仅有两个数使得这两个数和为目标值, 输出两个数的下标

   合并两个有序数组

   合并k个有序数组

   数组中出现次数超过一半的数字

   连续子数组的最大和

3. 搜索

   前中后序遍历二叉树

   按行遍历二叉树

   Z字型打印二叉树

   BFS

   DFS

4. 回溯

   实现一个全排列

   打印二叉树所有路径

5. DP

   股票问题,  一个数组, 下标代表天数, value代表价格, 只能买卖一次求最大利益, 允许买卖多次呢?

   给定两个字word1和word2，找到将word1转换为word2所需的最小步骤数。 （每个操作计为1步）。

   您对单词允许以下3种操作：

   a）插入字符

   b）删除字符

   c）替换字符

   最长公共子序列

   最长递增子序列

   最大连续子序列和

   0 1 背包

6. 



## 源码管理工具

1. Git 版本

   ![image-20201222141607354](https://homan-blog.oss-cn-beijing.aliyuncs.com/interview/image-20201222141607354.png)

2. 





## 实际项目

1. 第十一部分项目:
      技术上的问题大概就是上面列举出来的, 一面聊基础会问的很深和很细,二面和三面主要看你项目,我本次面试的重点说的项目是自研分布式文件系统(石杉老师架构班项目)，订单服务,消息推送服务开发等,要想进比如京东 百度 美团 阿里这样的大厂，技术深度和广度都需要很扎实,同时项目需要有含金量跟面试官有的聊,平时自己准备时:
   自研或二次开发中间件项目:
   1.自研的东西对比其他开源的内容有什么好处(可以从技术架构上,公司数据存储上,业务需求等方面考虑)
   2.自研的带来的收益有哪些(最后表现出来的结果)
   3.做这件事技术上最重要的点是哪些(用到的技术会被深问)
   4.哪个地方做的比较完美,哪些地方后续还需要扩展(明白自己系统的优势和劣势)
   业务项目   
   1.项目整理技术架构
   2.你负责的项目的核心业务流程,需要有亮点比如熔断限流降级,分布式事务,分布式锁,分库分表,消息中间件异步化等
   共性的内容:
   1.项目每天的访问量
   2.日活跃用户
   3.平时和高峰期的qps
   4.日交易量
   5.服务部署多少台每台机器的配置
   6.生产出现过的问题,如何去排查问题的